import{Vector3 as t,Vector2 as i,Box3 as n,BufferGeometry as s,BufferAttribute as e,Line3 as r,Plane as a}from"three";class o{constructor(n=new t,s=new t,e=new i){this.position=n,this.normal=s,this.uv=e}hash(t=1e6){const i=Math.floor(this.position.x*t),n=Math.floor(this.position.y*t),s=Math.floor(this.position.z*t),e=(i+n)*(i+n+1)*.5+n;return(e+s)*(e+s+1)*.5+s}equals(t){return this.hash()===t.hash()}toString(){return`Position = ${this.position.x}, ${this.position.y}, ${this.position.z}, Normal = ${this.normal.x}, ${this.normal.y}, ${this.normal.z}, UV = ${this.uv.x}, ${this.uv.y}`}}const h=0,l=1;class u{constructor(){this.vertices=[],this.cutVertices=[],this.triangles=[[],[]],this.constraints=[],this.indexMap=[],this.bounds=null,this.vertexAdjacency=[]}static fromGeometry(n){var s=n.attributes.position.array,e=n.attributes.normal.array,r=n.attributes.uv.array;const a=new u;for(let n=0;n<s.length/3;n++){const h=new t(s[3*n],s[3*n+1],s[3*n+2]),l=new t(e[3*n],e[3*n+1],e[3*n+2]),u=new i(r[2*n],r[2*n+1]);a.vertices.push(new o(h,l,u))}return a.triangles=[new Uint32Array(n.index?.array),[]],a.calculateBounds(),a}get triangleCount(){return(this.triangles[0].length+this.triangles[1].length)/3}get vertexCount(){return this.vertices.length+this.cutVertices.length}addCutFaceVertex(t,i,n){const s=new o(t,i,n);this.vertices.push(s),this.cutVertices.push(s),this.vertexAdjacency.push(this.vertices.length-1)}addMappedVertex(t,i){this.vertices.push(t),this.indexMap[i]=this.vertices.length-1}addTriangle(t,i,n,s){this.triangles[s].push(t,i,n)}addMappedTriangle(t,i,n,s){this.triangles[s].push(this.indexMap[t],this.indexMap[i],this.indexMap[n])}weldCutFaceVertices(){const t=[],i=[],n=[];let s=0;const e=new Map;this.cutVertices.forEach(((r,a)=>{const o=r.hash();e.has(o)?n[a]=e.get(o):(n[a]=s,e.set(o,s),t.push(this.cutVertices[a]),i.push(this.vertexAdjacency[a]),s++)}));for(let t=0;t<this.constraints.length;t++){const i=this.constraints[t];i.v1=n[i.v1],i.v2=n[i.v2]}this.cutVertices=t,this.vertexAdjacency=i}calculateBounds(){null===this.bounds&&(this.bounds=new n),this.vertices.length;const t=[];let i=-1;for(const n of this.vertices)t[i++]=n.position;this.bounds.setFromPoints(t)}calculateBounds_(){let t=this.vertices[0].position.clone(),i=t.clone();this.vertices.forEach((n=>{t.x=Math.min(t.x,n.position.x),t.y=Math.min(t.y,n.position.y),t.z=Math.min(t.z,n.position.z),i.x=Math.max(i.x,n.position.x),i.y=Math.max(i.y,n.position.y),i.z=Math.max(i.z,n.position.z)})),this.bounds=new n(t,i)}toGeometry(){const t=new s,i=this.vertices.length+this.cutVertices.length,n=new Array(3*i),r=new Array(3*i),a=new Array(2*i);let o=0,h=0,l=0;for(const t of this.vertices)n[o++]=t.position.x,n[o++]=t.position.y,n[o++]=t.position.z,r[h++]=t.normal.x,r[h++]=t.normal.y,r[h++]=t.normal.z,a[l++]=t.uv.x,a[l++]=t.uv.y;for(const t of this.cutVertices)n[o++]=t.position.x,n[o++]=t.position.y,n[o++]=t.position.z,r[h++]=t.normal.x,r[h++]=t.normal.y,r[h++]=t.normal.z,a[l++]=t.uv.x,a[l++]=t.uv.y;return t.addGroup(0,this.triangles[0].length,0),t.addGroup(this.triangles[0].length,this.triangles[1].length,1),t.setAttribute("position",new e(new Float32Array(n),3)),t.setAttribute("normal",new e(new Float32Array(r),3)),t.setAttribute("uv",new e(new Float32Array(a),2)),t.setIndex(new e(new Uint32Array(this.triangles.flat()),1)),t}}class g{constructor(t){this.parent=new Array(t),this.rank=new Array(t);for(let i=0;i<t;i++)this.parent[i]=i,this.rank[i]=1}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,i){const n=this.find(t),s=this.find(i);n!==s&&(this.rank[n]>this.rank[s]?this.parent[s]=n:this.rank[n]<this.rank[s]?this.parent[n]=s:(this.parent[s]=n,this.rank[n]+=1))}}const c=new a,d=new t;function p(t,i,n,s){return function(t,i,n,s,e){let r={x:i.x-t.x,y:i.y-t.y},a={x:s.x-n.x,y:s.y-n.y};const o=v(t),h=v(n);if(o===h)return e;const l=v(i);if(l===h)return e;const u=v(s);if(o===u)return e;if(l===u)return e;let g=(t.x-n.x)*a.y-(t.y-n.y)*a.x,c=(i.x-n.x)*a.y-(i.y-n.y)*a.x,d=(n.x-t.x)*r.y-(n.y-t.y)*r.x,p=(s.x-t.x)*r.y-(s.y-t.y)*r.x;return(g>=0&&c<=0||g<=0&&c>=0)&&(d>=0&&p<=0||d<=0&&p>=0)}(t,i,n,s,!1)}function f(i,n,s,e){let a=new r(i,n),o=new t;c.set(s,0).translate(e);const h=a.delta(d);let l=c.normal.dot(h);if(0===l)return 0===c.distanceToPoint(a.start)?{x:o.copy(a.start),s:0}:null;const u=-(a.start.dot(c.normal)+c.constant)/l;return u<0||u>1?null:{x:o.copy(a.start).addScaledVector(h,u),s:u}}function x(t,i,n){return(i.x-t.x)*(n.y-t.y)-(i.y-t.y)*(n.x-t.x)<=0}function v(t,i=1e6){const n=Math.floor(t.x*i),s=Math.floor(t.y*i);return(n+s)*(n+s+1)*.5+s}function y(t,i,n){return!(i.x*(t.x-n.x)+i.y*(t.y-n.y)+i.z*(t.z-n.z)<0)}class w{constructor(t,i,n,s,e){this.v1=t,this.v2=i,this.t1=void 0!==n?n:-1,this.t2=void 0!==s?s:-1,this.t1Edge=void 0!==e?e:0}equals(t){return this.v1===t.v1&&this.v2===t.v2||this.v1===t.v2&&this.v2===t.v1}toString(){return`Edge: T${this.t1}->T${this.t2} (V${this.v1}->V${this.v2})`}}class m{static getBinNumber(t,i,n){return t%2==0?t*n+i:(t+1)*n-i-1}static sort(t,i,n){if(n<=1)return t;i>t.length&&(i=t.length);const s=new Array(n).fill(0),e=new Array(t.length);for(let n=0;n<i;n++)s[t[n].bin]++;for(let t=1;t<n;t++)s[t]+=s[t-1];for(let n=i-1;n>=0;n--){const i=t[n].bin;s[i]--,e[s[i]]=t[n]}for(let n=i;n<e.length;n++)e[n]=t[n];return e}}class V{constructor(t,i){this.index=t,this.coords=i,this.bin=0}toString(){return`${this.coords} -> ${this.bin}`}}const T=-1;class M{constructor(n,s){if(this.normalizationScaleFactor=1,this.N=n.length,this.N>=3){this.triangleCount=2*this.N+1,this.triangulation=Array.from({length:this.triangleCount},(()=>new Array(6).fill(0))),this.skipTriangle=new Array(this.triangleCount).fill(!1),this.points=new Array(this.N+3),this.normal=s.clone().normalize();let a=n[0].position.clone().sub(n[1].position).normalize(),o=this.normal.clone(),h=new t;h.crossVectors(a,o).normalize();for(let t=0;t<this.N;t++){var e=n[t].position,r=new i(e.dot(a),e.dot(h));this.points[t]=new V(t,r)}}else this.triangleCount=0,this.triangulation=[],this.skipTriangle=[],this.points=[],this.normal=new t}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.discardTrianglesWithSuperTriangleVertices();const t=[];for(let i=0;i<this.triangleCount;i++)this.skipTriangle[i]||t.push(this.triangulation[i][0],this.triangulation[i][1],this.triangulation[i][2]);return t}normalizeCoordinates(){let t,n,s,e;t=s=1/0,n=e=-1/0;for(let i=0;i<this.N;i++)t=Math.min(t,this.points[i].coords.x),n=Math.max(n,this.points[i].coords.x),s=Math.min(s,this.points[i].coords.y),e=Math.max(e,this.points[i].coords.y);const r=Math.max(n-t,e-s);for(let n=0;n<this.N;n++){var a=this.points[n],o=new i((a.coords.x-t)/r,(a.coords.y-s)/r);this.points[n].coords=o}}sortPointsIntoBins(){const t=Math.round(Math.pow(this.N,.25)),i=t*t;for(let i=0;i<this.N;i++){var n=this.points[i];const s=Math.floor(.99*t*n.coords.y),e=Math.floor(.99*t*n.coords.x);n.bin=m.getBinNumber(s,e,t)}return m.sort(this.points,this.N,i)}computeTriangulation(){let t=0,i=0,n=this.sortPointsIntoBins();for(let s=0;s<this.N;s++){let e=n[s],r=0,a=!1;for(;!a&&!(r++>i||t===T);){let n=this.points[this.triangulation[t][0]].coords,s=this.points[this.triangulation[t][1]].coords,r=this.points[this.triangulation[t][2]].coords;x(n,s,e.coords)?x(s,r,e.coords)?x(r,n,e.coords)?(this.insertPointIntoTriangle(e,t,i),i+=2,t=i,a=!0):t=this.triangulation[t][5]:t=this.triangulation[t][4]:t=this.triangulation[t][3]}}}addSuperTriangle(){this.points[this.N]=new V(this.N,new i(-100,-100)),this.points[this.N+1]=new V(this.N+1,new i(0,100)),this.points[this.N+2]=new V(this.N+2,new i(100,-100)),this.triangulation[0][0]=this.N,this.triangulation[0][1]=this.N+1,this.triangulation[0][2]=this.N+2,this.triangulation[0][3]=T,this.triangulation[0][4]=T,this.triangulation[0][5]=T}insertPointIntoTriangle(t,i,n){const s=i,e=n+1,r=n+2;this.triangulation[e][0]=t.index,this.triangulation[e][1]=this.triangulation[i][1],this.triangulation[e][2]=this.triangulation[i][2],this.triangulation[e][3]=r,this.triangulation[e][4]=this.triangulation[i][4],this.triangulation[e][5]=s,this.triangulation[r][0]=t.index,this.triangulation[r][1]=this.triangulation[i][0],this.triangulation[r][2]=this.triangulation[i][1],this.triangulation[r][3]=s,this.triangulation[r][4]=this.triangulation[i][3],this.triangulation[r][5]=e,this.updateAdjacency(this.triangulation[i][3],i,r),this.updateAdjacency(this.triangulation[i][4],i,e),this.triangulation[s][1]=this.triangulation[i][2],this.triangulation[s][2]=this.triangulation[i][0],this.triangulation[s][0]=t.index,this.triangulation[s][4]=this.triangulation[i][5],this.triangulation[s][3]=e,this.triangulation[s][5]=r,this.restoreDelauneyTriangulation(t,s,e,r)}restoreDelauneyTriangulation(t,i,n,s){const e=[];for(e.push([i,this.triangulation[i][4]]),e.push([n,this.triangulation[n][4]]),e.push([s,this.triangulation[s][4]]);e.length>0;)if([i,n]=e.pop()??[T,T],n!=T){const s=this.swapQuadDiagonalIfNeeded(t.index,i,n);s&&(e.push([i,s.t3]),e.push([n,s.t4]))}}swapQuadDiagonalIfNeeded(t,i,n){let s=0,e=0,r=0,a=t,o=0,h=0;this.triangulation[n][3]===i?(s=this.triangulation[n][1],e=this.triangulation[n][0],r=this.triangulation[n][2],o=this.triangulation[n][4],h=this.triangulation[n][5]):this.triangulation[n][4]===i?(s=this.triangulation[n][2],e=this.triangulation[n][1],r=this.triangulation[n][0],o=this.triangulation[n][5],h=this.triangulation[n][3]):(s=this.triangulation[n][0],e=this.triangulation[n][2],r=this.triangulation[n][1],o=this.triangulation[n][3],h=this.triangulation[n][4]);return this.swapTest(this.points[s].coords,this.points[e].coords,this.points[r].coords,this.points[a].coords)?(this.updateAdjacency(o,n,i),this.updateAdjacency(this.triangulation[i][5],i,n),this.triangulation[i][0]=a,this.triangulation[i][1]=s,this.triangulation[i][2]=r,this.triangulation[n][0]=a,this.triangulation[n][1]=r,this.triangulation[n][2]=e,this.triangulation[n][3]=i,this.triangulation[n][4]=h,this.triangulation[n][5]=this.triangulation[i][5],this.triangulation[i][4]=o,this.triangulation[i][5]=n,{t3:o,t4:h}):null}discardTrianglesWithSuperTriangleVertices(){for(let t=0;t<this.triangleCount;t++)(this.triangleContainsVertex(t,this.N)||this.triangleContainsVertex(t,this.N+1)||this.triangleContainsVertex(t,this.N+2))&&(this.skipTriangle[t]=!0)}swapTest(t,i,n,s){const e=t.x-n.x,r=i.x-n.x,a=t.y-n.y,o=i.y-n.y,h=t.x-s.x,l=i.x-s.x,u=t.y-s.y,g=i.y-s.y,c=e*r+a*o,d=l*h+g*u;if(c>=0&&d>=0)return!1;if(c<0&&d<0)return!0;return(e*o-r*a)*d+(l*u-h*g)*c<0}triangleContainsVertex(t,i){return this.triangulation[t][0]===i||this.triangulation[t][1]===i||this.triangulation[t][2]===i}updateAdjacency(t,i,n){if(t===T)return;const s=this.findSharedEdge(t,i);s&&(this.triangulation[t][s]=n)}findSharedEdge(t,i){return t===T?null:this.triangulation[t][3]===i?3:this.triangulation[t][4]===i?4:this.triangulation[t][5]===i?5:null}}class C{constructor(t,i,n,s,e,r,a,o,h,l){this.q1=t,this.q2=i,this.q3=n,this.q4=s,this.t1=e,this.t2=r,this.t1L=a,this.t1R=o,this.t2L=h,this.t2R=l}toString(){return`T${this.t1}/T${this.t2} (V${this.q1},V${this.q2},V${this.q3},V${this.q4})`}}class A extends M{edgeVertex1=[0,0,0,0,1,2];edgeVertex2=[0,0,0,1,2,0];oppositePoint=[0,0,0,2,0,1];nextEdge=[0,0,0,4,5,3];previousEdge=[0,0,0,5,3,4];constructor(t,i,n){super(t,n),this.constraints=i,this.vertexTriangles=[]}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.constraints.length>0&&(this.applyConstraints(),this.discardTrianglesViolatingConstraints()),this.discardTrianglesWithSuperTriangleVertices();let t=[];for(let i=0;i<this.triangleCount;i++)this.skipTriangle[i]||(t.push(this.triangulation[i][0]),t.push(this.triangulation[i][1]),t.push(this.triangulation[i][2]));return t}applyConstraints(){this.vertexTriangles=new Array(this.N+3).fill(0);for(let t=0;t<this.triangulation.length;t++)this.vertexTriangles[this.triangulation[t][0]]=t,this.vertexTriangles[this.triangulation[t][1]]=t,this.vertexTriangles[this.triangulation[t][2]]=t;for(let t of this.constraints){if(t.v1===t.v2)continue;const i=this.findIntersectingEdges(t,this.vertexTriangles);this.removeIntersectingEdges(t,i)}}findIntersectingEdges(t,i){const n=[],s=this.findStartingEdge(i,t);if(!s)return n;n.push(s);let e=s.t1,r=s.t1Edge,a=e,o=!1;for(;!o;){a=e,e=this.triangulation[e][r];const i=this.points[t.v1].coords,s=this.points[t.v2].coords,l=this.points[this.triangulation[e][0]].coords,u=this.points[this.triangulation[e][1]].coords,g=this.points[this.triangulation[e][2]].coords;if(this.triangleContainsVertex(e,t.v2))o=!0;else if(this.triangulation[e][3]!==a&&p(i,s,l,u)){r=3;var h=new w(this.triangulation[e][0],this.triangulation[e][1],e,this.triangulation[e][3],r);n.push(h)}else if(this.triangulation[e][4]!==a&&p(i,s,u,g)){r=4;h=new w(this.triangulation[e][1],this.triangulation[e][2],e,this.triangulation[e][4],r);n.push(h)}else{if(this.triangulation[e][5]===a||!p(i,s,g,l)){console.warn("Failed to find final triangle, exiting early.");break}r=5;h=new w(this.triangulation[e][2],this.triangulation[e][0],e,this.triangulation[e][5],r);n.push(h)}}return n}findStartingEdge(t,i){let n,s,e,r=new w(-1,-1),a=i.v1,o=t[a],h=!1,l=null;const u=new Array(this.triangulation.length);for(;!l&&!h;){if(u[o]=!0,this.triangleContainsConstraint(o,i))return null;if(l=this.edgeConstraintIntersectsTriangle(o,i),l)break;if(n=this.triangulation[o][3],s=this.triangulation[o][4],e=this.triangulation[o][5],-1!==n&&!u[n]&&this.triangleContainsVertex(n,a))o=n;else if(-1!==s&&!u[s]&&this.triangleContainsVertex(s,a))o=s;else{if(-1===e||u[e]||!this.triangleContainsVertex(e,a)){h=!0;break}o=e}}if(l){const t=this.triangulation[o][this.edgeVertex1[l]],i=this.triangulation[o][this.edgeVertex2[l]],n=this.triangulation[o][l];return r=new w(t,i,o,n,l),r}return null}removeIntersectingEdges(t,i){let n,s=[],e=0;for(;i.length>0&&e<=i.length;){if(n=i.shift(),null==n)continue;let r=this.findQuadFromSharedEdge(n.t1,n.t1Edge);if(r)if(p(this.points[r.q4].coords,this.points[r.q3].coords,this.points[r.q1].coords,this.points[r.q2].coords)){this.swapQuadDiagonal(r,i,s,this.constraints);let n=new w(r.q3,r.q4,r.t1,r.t2,5);p(this.points[t.v1].coords,this.points[t.v2].coords,this.points[r.q3].coords,this.points[r.q4].coords)?i.push(n):(e=0,s.push(n))}else i.push(n);e++}s.length>0&&this.restoreConstrainedDelauneyTriangulation(t,s)}restoreConstrainedDelauneyTriangulation(t,i){let n=!0;for(;n;){n=!1;for(let s=0;s<i.length;s++){const e=i[s];if(e.equals(t))continue;let r=this.findQuadFromSharedEdge(e.t1,e.t1Edge);if(r&&this.swapTest(this.points[r.q1].coords,this.points[r.q2].coords,this.points[r.q3].coords,this.points[r.q4].coords)){this.swapQuadDiagonal(r,i,this.constraints,null);const t=r.q3,e=r.q4;i[s]=new w(t,e,r.t1,r.t2,5),n=!0}}}}discardTrianglesViolatingConstraints(){function t(t,i){return v({x:t,y:i})}this.skipTriangle.fill(!0);let i=new Set;for(let n=0;n<this.constraints.length;n++){const s=this.constraints[n];i.add(t(s.v1,s.v2))}let n,s,e,r,a,o,h=[];const l=new Array(this.triangulation.length);for(let u=0;u<this.triangleCount;u++)if(!l[u]&&(n=this.triangulation[u][0],s=this.triangulation[u][1],e=this.triangulation[u][2],r=i.has(t(n,s)),a=i.has(t(s,e)),o=i.has(t(e,n)),r||a||o))for(this.skipTriangle[u]=!1,h=[],r||h.push(this.triangulation[u][3]),a||h.push(this.triangulation[u][4]),o||h.push(this.triangulation[u][5]);h.length>0;){const r=h.shift();r&&-1!==r&&!l[r]&&(this.skipTriangle[r]=!1,l[r]=!0,n=this.triangulation[r][0],s=this.triangulation[r][1],e=this.triangulation[r][2],i.has(t(n,s))||h.push(this.triangulation[r][3]),i.has(t(s,e))||h.push(this.triangulation[r][4]),i.has(t(e,n))||h.push(this.triangulation[r][5]))}}triangleContainsConstraint(t,i){return!(t>=this.triangulation.length)&&!(this.triangulation[t][0]!==i.v1&&this.triangulation[t][1]!==i.v1&&this.triangulation[t][2]!==i.v1||this.triangulation[t][0]!==i.v2&&this.triangulation[t][1]!==i.v2&&this.triangulation[t][2]!==i.v2)}edgeConstraintIntersectsTriangle(t,i){const n=this.points[i.v1].coords,s=this.points[i.v2].coords,e=this.points[this.triangulation[t][0]].coords,r=this.points[this.triangulation[t][1]].coords,a=this.points[this.triangulation[t][2]].coords;return p(n,s,e,r)?3:p(n,s,r,a)?4:p(n,s,a,e)?5:null}findQuadFromSharedEdge(t,i){let n,s,e,r,a,o,h,l,u=this.triangulation[t][i],g=this.findSharedEdge(u,t);return g?(3===g?(s=this.triangulation[u][0],n=this.triangulation[u][1],e=this.triangulation[u][2]):4===g?(s=this.triangulation[u][1],n=this.triangulation[u][2],e=this.triangulation[u][0]):(s=this.triangulation[u][2],n=this.triangulation[u][0],e=this.triangulation[u][1]),r=this.triangulation[t][this.oppositePoint[i]],a=this.triangulation[t][this.previousEdge[i]],o=this.triangulation[t][this.nextEdge[i]],h=this.triangulation[u][this.nextEdge[g]],l=this.triangulation[u][this.previousEdge[g]],new C(n,s,e,r,t,u,a,o,h,l)):null}swapQuadDiagonal(t,i,n,s){const e=t.t1,r=t.t2,a=t.t1R,o=t.t1L,h=t.t2R,l=t.t2L;this.triangulation[e][0]=t.q4,this.triangulation[e][1]=t.q1,this.triangulation[e][2]=t.q3,this.triangulation[r][0]=t.q4,this.triangulation[r][1]=t.q3,this.triangulation[r][2]=t.q2,this.triangulation[e][3]=o,this.triangulation[e][4]=l,this.triangulation[e][5]=r,this.triangulation[r][3]=e,this.triangulation[r][4]=h,this.triangulation[r][5]=a,this.updateAdjacency(l,r,e),this.updateAdjacency(a,e,r),this.updateEdgesAfterSwap(i,e,r,o,a,l,h),this.updateEdgesAfterSwap(n,e,r,o,a,l,h),this.updateEdgesAfterSwap(s,e,r,o,a,l,h),this.vertexTriangles[t.q1]=e,this.vertexTriangles[t.q2]=r}updateEdgesAfterSwap(t,i,n,s,e,r,a){if(t)for(let o of t)o.t1===i&&o.t2===e?(o.t1=n,o.t2=e,o.t1Edge=5):o.t1===i&&o.t2===s?o.t1Edge=3:o.t1===e&&o.t2===i?o.t2=n:o.t1===s&&o.t2===i||(o.t1===n&&o.t2===a?o.t1Edge=4:o.t1===n&&o.t2===r?(o.t1=i,o.t2=r,o.t1Edge=4):o.t1===a&&o.t2===n||o.t1===r&&o.t2===n&&(o.t2=i))}}function z(t,n,s,e,r,a){const g=new u,c=new u,d=new Array(t.vertexCount).fill(!1);for(let i=0;i<t.vertices.length;i++){var p=t.vertices[i];d[i]=y(p.position,n,s),(d[i]?g:c).addMappedVertex(p,i)}const f=t.vertices.length;for(let i=0;i<t.cutVertices.length;i++){p=t.cutVertices[i];d[i+f]=y(p.position,n,s),(d[i+f]?g:c).addMappedVertex(p,i+f)}return S(t,g,c,n,s,d,h),S(t,g,c,n,s,d,l),function(t,n,s,e,r,a){t.weldCutFaceVertices();const h=s.clone().negate();if(t.cutVertices.length<3)return;const u=a?new M(t.cutVertices,h):new A(t.cutVertices,t.constraints,h),g=u.triangulate();for(let a=0;a<t.cutVertices.length;a++){var c=t.cutVertices[a],d=u.points[a];const l=new i(u.normalizationScaleFactor*d.coords.x*e.x+r.x,u.normalizationScaleFactor*d.coords.y*e.y+r.y),g=new o(c.position.clone(),h,l.clone()),p=new o(c.position.clone(),s,l.clone());t.cutVertices[a]=g,n.cutVertices[a]=p}let p=t.vertices.length,f=n.vertices.length;for(let i=0;i<g.length;i+=3)t.addTriangle(p+g[i],p+g[i+1],p+g[i+2],l),n.addTriangle(f+g[i],f+g[i+2],f+g[i+1],l)}(g,c,n,e,r,a),{topSlice:g,bottomSlice:c}}function S(t,i,n,s,e,r,a){const o=t.triangles[a];let h,l,u;for(let g=0;g<o.length;g+=3)h=o[g],l=o[g+1],u=o[g+2],r[h]&&r[l]&&r[u]?i.addMappedTriangle(h,l,u,a):r[h]||r[l]||r[u]?r[l]&&r[u]&&!r[h]?E(l,u,h,s,e,t,i,n,a,!0):r[u]&&r[h]&&!r[l]?E(u,h,l,s,e,t,i,n,a,!0):r[h]&&r[l]&&!r[u]?E(h,l,u,s,e,t,i,n,a,!0):r[l]||r[u]||!r[h]?r[u]||r[h]||!r[l]?r[h]||r[l]||!r[u]||E(h,l,u,s,e,t,i,n,a,!1):E(u,h,l,s,e,t,i,n,a,!1):E(l,u,h,s,e,t,i,n,a,!1):n.addMappedTriangle(h,l,u,a)}function E(n,s,e,r,a,o,h,l,u,g){let c=n<o.vertices.length?o.vertices[n]:o.cutVertices[n-o.vertices.length],d=s<o.vertices.length?o.vertices[s]:o.cutVertices[s-o.vertices.length],p=e<o.vertices.length?o.vertices[e]:o.cutVertices[e-o.vertices.length];const x=f(c.position,p.position,r,a),v=f(d.position,p.position,r,a);if(x&&v){const r=new t(c.normal.x+x.s*(p.normal.x-c.normal.x),c.normal.y+x.s*(p.normal.y-c.normal.y),c.normal.z+x.s*(p.normal.z-c.normal.z)).normalize(),a=new t(d.normal.x+v.s*(p.normal.x-d.normal.x),d.normal.y+v.s*(p.normal.y-d.normal.y),d.normal.z+v.s*(p.normal.z-d.normal.z)).normalize(),o=new i(c.uv.x+x.s*(p.uv.x-c.uv.x),c.uv.y+x.s*(p.uv.y-c.uv.y)),f=new i(d.uv.x+v.s*(p.uv.x-d.uv.x),d.uv.y+v.s*(p.uv.y-d.uv.y));h.addCutFaceVertex(x.x,r,o),h.addCutFaceVertex(v.x,a,f),l.addCutFaceVertex(x.x,r,o),l.addCutFaceVertex(v.x,a,f);const y=h.vertices.length-2,m=h.vertices.length-1,V=l.vertices.length-2,T=l.vertices.length-1;g?(h.addTriangle(m,y,h.indexMap[s],u),h.addTriangle(y,h.indexMap[n],h.indexMap[s],u),l.addTriangle(l.indexMap[e],V,T,u),h.constraints.push(new w(h.cutVertices.length-2,h.cutVertices.length-1)),l.constraints.push(new w(l.cutVertices.length-1,l.cutVertices.length-2))):(h.addTriangle(y,m,h.indexMap[e],u),l.addTriangle(l.indexMap[n],l.indexMap[s],V,u),l.addTriangle(l.indexMap[s],T,V,u),h.constraints.push(new w(h.cutVertices.length-1,h.cutVertices.length-2)),l.constraints.push(new w(l.cutVertices.length-2,l.cutVertices.length-1)))}}const q={fragmentCount:50,fracturePlanes:{x:!0,y:!0,z:!0},fractureMode:"Convex",textureScale:new i(1,1),textureOffset:new i};function N(i,n){const s={...q,...n};let e=[u.fromGeometry(i.geometry)];for(;e.length<s.fragmentCount;){const i=e.shift();if(!i)continue;i?.calculateBounds();let n=new t(s.fracturePlanes.x?2*Math.random()-1:0,s.fracturePlanes.y?2*Math.random()-1:0,s.fracturePlanes.z?2*Math.random()-1:0).normalize(),r=new t;if(i.bounds.getCenter(r),r.add(new t(1e-4*Math.random(),1e-4*Math.random(),1e-4*Math.random())),"Non-Convex"===s.fractureMode){const{topSlice:t,bottomSlice:a}=z(i,n,r,s.textureScale,s.textureOffset,!1),o=b(t),h=b(a);e.push(...o),e.push(...h)}else{const{topSlice:t,bottomSlice:a}=z(i,n,r,s.textureScale,s.textureOffset,!0);e.push(t),e.push(a)}}return e}function b(t){const i=new g(t.vertexCount),n={},s=t.vertices.length,e=t.cutVertices.length,r=new Map;t.vertices.forEach(((t,n)=>{const s=t.hash(),e=r.get(s);void 0===e?r.set(s,n):i.union(e,n)}));for(let n=0;n<e;n++)i.union(t.vertexAdjacency[n],n+s);const a=t.triangles;for(let t=0;t<a.length;t++)for(let s=0;s<a[t].length;s+=3){const e=a[t][s],r=a[t][s+1],o=a[t][s+2];i.union(e,r),i.union(r,o);const h=i.find(e);n[h]||(n[h]=[[],[]]),n[h][t].push(e,r,o)}const o={},h=Array(t.vertexCount);for(let n=0;n<s;n++){const s=i.find(n);o[s]||(o[s]=new u),o[s].vertices.push(t.vertices[n]),h[n]=o[s].vertices.length-1}for(let n=0;n<e;n++){const e=i.find(n+s);o[e].cutVertices.push(t.cutVertices[n]),h[n+s]=o[e].vertices.length+o[e].cutVertices.length-1}for(const s of Object.keys(n)){let e=Number(s),r=i.parent[e];for(let i=0;i<t.triangles.length;i++)for(const t of n[e][i]){const n=h[t];o[r].triangles[i].push(n)}}return Object.values(o)}export{N as Fracture,z as Slice,q as option};
