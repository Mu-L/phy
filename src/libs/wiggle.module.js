import{Vector3 as t,Mesh as e,SphereGeometry as i,MeshBasicMaterial as n,Quaternion as s,PlaneGeometry as r,CylinderGeometry as o,Object3D as a,Color as l,InstancedMesh as h,ShaderLib as c,Group as p}from"three";const g={velocity:.1,maxStretch:.1},d=new t,u=new t,f=new e(new i(.03),new n({transparent:!0}));class _{constructor(e,i={},n=!1){this.options={...g,...i};const r=e.clone();e.parent.add(r),r.add(e),this.target=e,this.targetHelper=f.clone(),i.scene&&i.scene.add(this.targetHelper),this.currentHelper=f.clone(),i.scene&&i.scene.add(this.currentHelper),this.currentHelper.add(f.clone()),this.currentHelper.children[0].position.y=-.1,this._isFirstStep=!0,this.originPosition=e.position.clone(),this.originRotation=e.rotation.clone(),this.oldBoneWorldPosition=new t,this.oldBoneWorldRotation=new s,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation),this.restLength=this.target.parent.position.length()}reset(){this._isFirstStep=!0,this.target.position.copy(this.originPosition),this.target.rotation.copy(this.originRotation),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}dispose(){this.reset();const t=this.target.parent,e=t.parent;e.remove(t),e.add(this.target)}update(t=null){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;let e=1;if((t=Math.min(t,100))>.01&&(e=2),t>=100&&(e=25),!(t<.006))for(let t=0;t<e;t++)this.step(.0085*100)}step(t){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),this._isFirstStep&&(this._isFirstStep=!1,this.oldBoneWorldPosition.copy(this.targetHelper.position)),d.copy(this.oldBoneWorldPosition).lerp(this.targetHelper.position,Math.min(this.options.velocity*t,.99999)),this.target.position.copy(d),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(d);const e=this.target.parent.getWorldPosition(u);this.currentHelper.position.copy(d),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(e);const i=this.target.position.clone();i.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,i),this.target.position.set(0,0,0),this.target.updateMatrix()}}
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */function m(t,e){if(!t)throw new Error(e)}function v(t,e){return null!=t?t:e}
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */class x{static MAX_DELTA_TIME_MS=1/60*1e3*4;_listeners=[];_currentAnimationStep=0;_currentTime=0;_springTime=0;_currentValue=0;_currentVelocity=0;_isAnimating=!1;_oscillationVelocityPairs=[];constructor(t={}){this._config={fromValue:v(t.fromValue,0),toValue:v(t.toValue,1),stiffness:v(t.stiffness,100),damping:v(t.damping,10),mass:v(t.mass,1),initialVelocity:v(t.initialVelocity,0),overshootClamping:v(t.overshootClamping,!1),allowsOverdamping:v(t.allowsOverdamping,!1),restVelocityThreshold:v(t.restVelocityThreshold,.001),restDisplacementThreshold:v(t.restDisplacementThreshold,1e-4),maxVelocity:v(t.maxVelocity,1/0)},this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}start(){const{fromValue:t,toValue:e,initialVelocity:i}=this._config;return t===e&&0===i||(this._reset(),this._isAnimating=!0),this}stop(){return this._isAnimating?(this._isAnimating=!1,this._notifyListeners("onStop"),this._currentAnimationStep&&(cancelAnimationFrame(this._currentAnimationStep),this._currentAnimationStep=0),this):this}get currentValue(){return this._currentValue}get currentVelocity(){return this._currentVelocity}get isAtRest(){return this._isSpringAtRest()}get isAnimating(){return this._isAnimating}updateConfig(t){this._advanceSpringToTime(Date.now());const e={fromValue:this._currentValue,initialVelocity:this._currentVelocity};return this._config={...this._config,...e,...t},this._reset(),this}onStart(t){return this._listeners.push({onStart:t}),this}onUpdate(t){return this._listeners.push({onUpdate:t}),this}onStop(t){return this._listeners.push({onStop:t}),this}removeListener(t){return this._listeners=this._listeners.reduce(((e,i)=>(-1!==Object.values(i).indexOf(t)||e.push(i),e)),[]),this}removeAllListeners(){return this._listeners=[],this}_reset(){this._currentTime=Date.now(),this._springTime=0,this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}_notifyListeners(t){this._listeners.forEach((e=>{const i=e[t];"function"==typeof i&&i(this)}))}_step(t){this._advanceSpringToTime(t,!0)}_advanceSpringToTime(t,e=!1){if(!this._isAnimating)return;let i=t-this._currentTime;i>x.MAX_DELTA_TIME_MS&&(i=x.MAX_DELTA_TIME_MS),this._springTime+=i;const n=this._config.damping,s=this._config.mass,r=this._config.stiffness,o=this._config.fromValue,a=this._config.toValue,l=-this._config.initialVelocity,h=this._config.maxVelocity;m(s>0,"Mass value must be greater than 0"),m(r>0,"Stiffness value must be greater than 0");let c=n/(2*Math.sqrt(r*s));const p=Math.sqrt(r/s)/1e3,g=p*Math.sqrt(1-c*c),d=p*Math.sqrt(c*c-1),u=a-o;c>1&&!this._config.allowsOverdamping&&(c=1);let f=0,_=0;const v=this._springTime;if(c<1){const t=Math.exp(-c*p*v);f=a-t*((l+c*p*u)/g*Math.sin(g*v)+u*Math.cos(g*v)),_=c*p*t*(Math.sin(g*v)*(l+c*p*u)/g+u*Math.cos(g*v))-t*(Math.cos(g*v)*(l+c*p*u)-g*u*Math.sin(g*v))}else if(1===c){const t=Math.exp(-p*v);f=a-t*(u+(l+p*u)*v),_=t*(l*(v*p-1)+v*u*(p*p))}else{const t=Math.exp(-c*p*v);f=a-t*((l+c*p*u)*Math.sinh(d*v)+d*u*Math.cosh(d*v))/d,_=t*c*p*(Math.sinh(d*v)*(l+c*p*u)+u*d*Math.cosh(d*v))/d-t*(d*Math.cosh(d*v)*(l+c*p*u)+d*d*u*Math.sinh(d*v))/d}return _=Math.max(-h,Math.min(h,_)),this._currentTime=t,this._currentValue=f,this._currentVelocity=_,e&&(this._notifyListeners("onUpdate"),this._isAnimating)&&(this._isSpringOvershooting()||this._isSpringAtRest())?(0!==r&&(this._currentValue=a,this._currentVelocity=0,this._notifyListeners("onUpdate")),void this.stop()):void 0}_isSpringOvershooting(){const{stiffness:t,fromValue:e,toValue:i,overshootClamping:n}=this._config;let s=!1;return n&&0!==t&&(s=e<i?this._currentValue>i:this._currentValue<i),s}_isSpringAtRest(){const{stiffness:t,toValue:e,restDisplacementThreshold:i,restVelocityThreshold:n}=this._config,s=Math.abs(this._currentVelocity)<=n;return 0!==t&&Math.abs(e-this._currentValue)<=i&&s}}const M={stiffness:500,damping:17},V=new t,y=new t,w=new e(new i(.03),new n({transparent:!0}));class S{constructor(e,i={}){this.options={...M,...i};const n=e.clone();e.parent.add(n),n.add(e),this.target=e,this.targetHelper=w.clone(),i.scene&&i.scene.add(this.targetHelper),this.currentHelper=w.clone(),i.scene&&i.scene.add(this.currentHelper),this.currentHelper.add(w.clone()),this.currentHelper.children[0].position.y=-.1,this._isFirstStep=!0;const r={stiffness:this.options.stiffness,damping:this.options.damping};this.springX=new x({fromValue:0,toValue:0,...r}),this.springY=new x({fromValue:0,toValue:0,...r}),this.springZ=new x({fromValue:0,toValue:0,...r}),this.originPosition=e.position.clone(),this.originRotation=e.rotation.clone(),this.oldBoneWorldPosition=new t,this.oldBoneWorldRotation=new s,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation),this.restLength=this.target.parent.position.length(),this.reset()}reset(){this._isFirstStep=!0,this.target.position.copy(this.originPosition),this.target.rotation.copy(this.originRotation),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}dispose(){this.reset();const t=this.target.parent,e=t.parent;e.remove(t),e.add(this.target)}update(t=null){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;let e=1;if((t=Math.min(t,100))>.01&&(e=2),t>=100&&(e=25),!(t<.006))for(let t=0;t<e;t++)this.step(.0085*100)}step(t){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),this._isFirstStep&&(this._isFirstStep=!1,this.springX.updateConfig({fromValue:this.targetHelper.position.x}),this.springY.updateConfig({fromValue:this.targetHelper.position.y}),this.springZ.updateConfig({fromValue:this.targetHelper.position.z})),this.springX.updateConfig({toValue:this.targetHelper.position.x}).start(),this.springY.updateConfig({toValue:this.targetHelper.position.y}).start(),this.springZ.updateConfig({toValue:this.targetHelper.position.z}).start();const e=Date.now();this.springX._step(e),this.springY._step(e),this.springZ._step(e),this.target.position.set(this.springX.currentValue,this.springY.currentValue,this.springZ.currentValue),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(V);const i=this.target.parent.getWorldPosition(y);this.currentHelper.position.copy(V),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(i);const n=this.target.position.clone();n.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,n),this.target.position.set(0,0,0),this.target.updateMatrix()}}class B{constructor(t,{multiplier:e=1}={}){this.wiggleBones=[],t.bones.forEach((t=>{t.userData.wiggleVelocity?this.wiggleBones.push(new _(t,{velocity:t.userData.wiggleVelocity*e})):t.userData.wiggleStiffness&&this.wiggleBones.push(new S(t,{stiffness:t.userData.wiggleStiffness,damping:t.userData.wiggleDamping}))}))}reset(){this.wiggleBones.forEach((t=>t.reset()))}dispose(){this.wiggleBones.forEach((t=>t.dispose())),this.wiggleBones=[]}update(t){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;this.wiggleBones.forEach((e=>e.update(t)))}}const W=new r,A=new o(1,1,1);A.rotateX(Math.PI/2);const T=new a,H=new t,P=new t,b=new l("red");class C extends a{constructor({skeleton:e=null,dotSize:i=.33,lineWidth:s=.025,colorStatic:r="#006CFF",colorDynamic:o="#FC7229",extraBoneMultiplier:a=1}={}){if(super(),!e)return console.log("Failed to create WiggleRigHelper: missing skeleton on initialization");this.links=e.bones.reduce(((t,e)=>(e.children.forEach((i=>t.push([e,i]))),t)),[]),this.finalBones=e.bones.filter((t=>0===t.children.length)),this.finalBoneLengths=this.finalBones.map((t=>t.position.length())),this.finalBoneExtensionPositions=this.finalBones.map((()=>new t)),this.dots=new h(W,new L({color:16777215,transparent:!0,depthTest:!1}),e.bones.length+this.finalBoneLengths.length),this.dots.renderOrder=999,this.dots.frustumCulled=!1;for(let t=0;t<e.bones.length+this.finalBones.length;t++)b.setStyle(0===t?r:o),this.dots.setColorAt(t,b);this.add(this.dots),this.dots.onBeforeRender=(t,n,s)=>{e.bones.forEach(((t,e)=>{const n=t.getWorldPosition(H);T.position.copy(n),T.scale.setScalar(i),T.rotation.copy(s.rotation),T.updateMatrix(),this.dots.setMatrixAt(e,T.matrix)})),this.finalBones.forEach(((t,n)=>{H.set(0,this.finalBoneLengths[0]*a,0);const r=t.localToWorld(H);this.finalBoneExtensionPositions[n].copy(r),T.position.copy(r),T.scale.setScalar(i),T.rotation.copy(s.rotation),T.updateMatrix(),this.dots.setMatrixAt(e.bones.length+n,T.matrix)})),this.dots.instanceMatrix.needsUpdate=!0,this.dots.computeBoundingSphere()},this.lines=new h(A,new n({color:o,transparent:!0,depthTest:!1}),this.links.length+this.finalBones.length),T.scale.set(0,0,0),T.updateMatrix();for(let t=0;t<this.links.length+this.finalBones.length;t++)this.lines.setMatrixAt(t,T.matrix);this.lines.renderOrder=998,this.lines.frustumCulled=!1,this.add(this.lines),this.lines.onBeforeRender=()=>{this.links.forEach((([t,e],i)=>{const n=t.getWorldPosition(H),r=e.getWorldPosition(P);T.position.copy(n).lerp(r,.5),T.scale.set(s,s,n.distanceTo(r)),T.lookAt(n),T.updateMatrix(),this.lines.setMatrixAt(i,T.matrix)})),this.finalBones.forEach(((t,e)=>{const i=t.getWorldPosition(H),n=this.finalBoneExtensionPositions[e];T.position.copy(i).lerp(n,.5),T.scale.set(s,s,i.distanceTo(n)),T.lookAt(i),T.updateMatrix(),this.lines.setMatrixAt(this.links.length+e,T.matrix)})),this.lines.instanceMatrix.needsUpdate=!0,this.lines.computeBoundingSphere()}}dispose(){super.dispose()}}class L extends n{constructor(t){super(t),this.uniforms={...c.standard.uniforms},this.type="WiggleBonesHelperDotMaterial",this.vertexShader="\n            #include <common>\n            #include <batching_pars_vertex>\n            #include <uv_pars_vertex>\n            #include <envmap_pars_vertex>\n            #include <color_pars_vertex>\n            #include <fog_pars_vertex>\n            #include <morphtarget_pars_vertex>\n            #include <skinning_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n            #include <clipping_planes_pars_vertex>\n            varying vec2 vvUv;\n            void main() {\n                #include <uv_vertex>\n                #include <color_vertex>\n                #include <morphcolor_vertex>\n                #include <batching_vertex>\n                #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n                    #include <beginnormal_vertex>\n                    #include <morphnormal_vertex>\n                    #include <skinbase_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n                #endif\n                #include <begin_vertex>\n                #include <morphtarget_vertex>\n                #include <skinning_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n                #include <clipping_planes_vertex>\n                #include <worldpos_vertex>\n                #include <envmap_vertex>\n                #include <fog_vertex>\n\n                vvUv = uv;\n            }\n        ",this.fragmentShader="\n            uniform vec3 diffuse;\n            uniform float opacity;\n            #ifndef FLAT_SHADED\n            varying vec3 vNormal;\n            #endif\n            #include <common>\n            #include <dithering_pars_fragment>\n            #include <color_pars_fragment>\n            #include <uv_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <alphatest_pars_fragment>\n            #include <alphahash_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <envmap_common_pars_fragment>\n            #include <envmap_pars_fragment>\n            #include <fog_pars_fragment>\n            #include <specularmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <clipping_planes_pars_fragment>\n            varying vec2 vvUv;\n            void main() {\n                vec4 diffuseColor = vec4( diffuse, opacity );\n                #include <clipping_planes_fragment>\n                #include <logdepthbuf_fragment>\n                #include <map_fragment>\n                #include <color_fragment>\n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <alphahash_fragment>\n                #include <specularmap_fragment>\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n                #ifdef USE_LIGHTMAP\n                    vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n                    reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n                #else\n                    reflectedLight.indirectDiffuse += vec3( 1.0 );\n                #endif\n                #include <aomap_fragment>\n                reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n                vec3 outgoingLight = reflectedLight.indirectDiffuse;\n                #include <envmap_fragment>\n                #include <opaque_fragment>\n\n                float circ = length(vvUv - vec2(0.5)) * 1.5;\n                gl_FragColor.a = smoothstep(0.5, 0.48, circ);\n                gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), smoothstep(0.35, 0.37, circ));\n                gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, gl_FragColor.a);\n\n                gl_FragColor.a += smoothstep(0.75, 0.5, circ) * 0.15;\n                gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);\n                // gl_FragColor.a *= 0.9;\n\n\n                #include <tonemapping_fragment>\n                #include <colorspace_fragment>\n                #include <fog_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n            }\n        "}}class E extends p{constructor(t,e={}){super(),this.skeleton=t,this.wiggleBones=[],this.addStructure()}addStructure(){const t=this.skeleton.bones.length;for(let e=0;e<t;e++)0===e?this.rootBone=this.skeleton.bones[e]:this.wiggleBones.push(new _(this.skeleton.bones[e],{stiffness:700,damping:28}))}addHelper(){this.helper=new C({skeleton:this.skeleton,dotSize:.1,lineWidth:.01}),this.add(this.helper)}updateMatrixWorld(t){super.updateMatrixWorld(t),this.wiggleBones.forEach((t=>t.update()))}}export{x as Spring,_ as WiggleBone,E as WiggleGroup,B as WiggleRig,C as WiggleRigHelper,S as WiggleSpring};
